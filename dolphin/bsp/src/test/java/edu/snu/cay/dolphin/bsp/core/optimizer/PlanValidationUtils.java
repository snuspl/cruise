/*
 * Copyright (C) 2015 Seoul National University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package edu.snu.cay.dolphin.bsp.core.optimizer;

import edu.snu.cay.services.em.optimizer.api.DataInfo;
import edu.snu.cay.services.em.optimizer.api.EvaluatorParameters;
import edu.snu.cay.services.em.optimizer.impl.DataInfoImpl;
import edu.snu.cay.services.em.optimizer.impl.EvaluatorParametersImpl;
import edu.snu.cay.services.em.plan.api.Plan;
import edu.snu.cay.services.em.plan.api.TransferStep;

import java.util.*;

import static org.junit.Assert.*;

/**
 * Utility class for checking the validity of plans generated by optimizers.
 */
final class PlanValidationUtils {

  private PlanValidationUtils() {
  }

  /**
   * Checks the validity of the generated plan.
   * @param activeEvaluators the collection of evaluator parameters
   * @param plan the generated plan
   * @param numAvailableEvals the number of available evaluators
   */
  static void checkPlan(final Map<String, List<EvaluatorParameters>> activeEvaluators,
                        final Plan plan,
                        final int numAvailableEvals) {
    final Map<String, List<EvaluatorParameters>> applied = applyPlan(activeEvaluators, plan);
    for (final Map.Entry<String, List<EvaluatorParameters>> entry : applied.entrySet()) {
      final String namespace = entry.getKey();
      final List<EvaluatorParameters> evaluatorParams = entry.getValue();
      assertTrue(
          String.format(
              "After optimization, active evaluators %d must be less than or equal to available evaluators %d",
              evaluatorParams.size(), numAvailableEvals),
          evaluatorParams.size() <= numAvailableEvals);
      assertEquals("Data should not be changed",
          getSumOfDataInfos(activeEvaluators.get(namespace)),
          getSumOfDataInfos(applied.get(namespace)));
    }
  }

  /**
   * @param evaluators the collection of evaluator parameters
   * @return the total number of data blocks in the specified collection of evaluator parameters.
   */
  private static Integer getSumOfDataInfos(final Collection<EvaluatorParameters> evaluators) {
    int numTotalUnits = 0;
    for (final EvaluatorParameters evaluator : evaluators) {
      numTotalUnits += evaluator.getDataInfo().getNumBlocks();
    }
    return numTotalUnits;
  }

  /**
   * Generates the collection of evaluator parameters after applying the specified plan.
   * Each evaluator id should be unique in the specified collection of evaluator parameters.
   * @param activeEvaluatorsMap the collection of evaluator parameters to which the plan is applied
   * @param plan the plan that is applied to the specified collection of evaluator parameters
   * @return the collection of evaluator parameters after applying the specified plan
   */
  private static Map<String, List<EvaluatorParameters>> applyPlan(
      final Map<String, List<EvaluatorParameters>> activeEvaluatorsMap,
      final Plan plan) {

    final Map<String, List<EvaluatorParameters>> resultMap = new HashMap<>();

    for (final Map.Entry<String, List<EvaluatorParameters>> entry : activeEvaluatorsMap.entrySet()) {
      final String namespace = entry.getKey();
      final List<EvaluatorParameters> activeEvaluatorsList = entry.getValue();

      final Map<String, EvaluatorParameters> evaluatorMap = new HashMap<>();

      // add existing evaluators
      for (final EvaluatorParameters evaluator : activeEvaluatorsList) {
        assertNull(String.format("Evaluator id %s should be unique", evaluator.getId()),
            evaluatorMap.put(evaluator.getId(), makeCopy(evaluator)));
      }

      // add evaluators generated by the plan
      for (final String idToAdd : plan.getEvaluatorsToAdd(namespace)) {
        assertNull(String.format("Evaluator id %s should be unique", idToAdd),
            evaluatorMap.put(idToAdd, getNewEvaluatorParameters(idToAdd)));
      }

      // apply transfer steps generated by the plan
      for (final TransferStep transferStep : plan.getTransferSteps(namespace)) {
        final EvaluatorParameters src = evaluatorMap.get(transferStep.getSrcId());
        final EvaluatorParameters dest = evaluatorMap.get(transferStep.getDstId());
        assertNotNull(String.format("Src evaluator %s to transfer data does not exist", transferStep.getSrcId()), src);
        assertNotNull(String.format("Dest evaluator %s to transfer data does not exist",
            transferStep.getDstId()), dest);

        removeData(src, transferStep.getDataInfo());
        addData(dest, transferStep.getDataInfo());
      }

      // remove evaluators by the plan
      for (final String idToDelete : plan.getEvaluatorsToDelete(namespace)) {
        final EvaluatorParameters evaluator = evaluatorMap.remove(idToDelete);
        assertNotNull(String.format("No evaluator whose id is %s", idToDelete), evaluator);
        assertEquals(String.format("Evaluator %s to delete has data", idToDelete),
            0, evaluator.getDataInfo().getNumBlocks());
      }

      resultMap.put(namespace, new ArrayList<>(evaluatorMap.values()));
    }

    return resultMap;
  }

  /**
   * @param id the id used for a new evaluator
   * @return new evaluator parameters
   */
  private static EvaluatorParameters getNewEvaluatorParameters(final String id) {
    return new EvaluatorParametersImpl(id, new DataInfoImpl(), new HashMap<>(0));
  }

  /**
   * @param evaluatorParameters the evaluator parameters to copy
   * @return a copy of the specified evaluator parameters
   */
  private static EvaluatorParameters makeCopy(final EvaluatorParameters evaluatorParameters) {
    final DataInfo dataInfoCopy = new DataInfoImpl(evaluatorParameters.getDataInfo().getNumBlocks());
    return new EvaluatorParametersImpl(
        evaluatorParameters.getId(), dataInfoCopy, (Map<String, Double>) evaluatorParameters.getMetrics());
  }

  /**
   * Removes the specified data from the evaluator parameters.
   * Assumes that the specified data information is valid.
   * @param evaluator the evaluator parameters from which the specified data is removed
   * @param dataInfoToRemove the information of data to remove
   */
  private static void removeData(final EvaluatorParameters evaluator, final DataInfo dataInfoToRemove) {
    final String id = evaluator.getId();

    final int numRemainedBlocks = evaluator.getDataInfo().getNumBlocks() - dataInfoToRemove.getNumBlocks();
    assertTrue(String.format("Evaluator %s does not have enough data to transfer", id), numRemainedBlocks >= 0);

    evaluator.getDataInfo().setNumBlocks(numRemainedBlocks);
  }

  /**
   * Adds the specified data to the evaluator parameters.
   * Assumes that the specified data information is valid.
   * @param evaluator the evaluator parameters to which the specified data is added
   * @param dataInfoToAdd the information of data to add
   */
  private static void addData(final EvaluatorParameters evaluator, final DataInfo dataInfoToAdd) {
    final int numExistingBlocks = evaluator.getDataInfo().getNumBlocks();
    evaluator.getDataInfo().setNumBlocks(numExistingBlocks + dataInfoToAdd.getNumBlocks());
  }
}
