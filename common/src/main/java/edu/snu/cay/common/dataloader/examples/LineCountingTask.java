/*
 * Copyright (C) 2017 Seoul National University
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package edu.snu.cay.common.dataloader.examples;

import org.apache.hadoop.io.LongWritable;
import org.apache.hadoop.io.Text;
import org.apache.reef.annotations.audience.TaskSide;
import org.apache.reef.io.data.loading.api.DataSet;
import org.apache.reef.io.network.util.Pair;
import org.apache.reef.tang.annotations.Unit;
import org.apache.reef.task.Task;
import org.apache.reef.task.TaskMessage;
import org.apache.reef.task.TaskMessageSource;
import org.apache.reef.task.events.CloseEvent;
import org.apache.reef.task.events.DriverMessage;
import org.apache.reef.util.Optional;
import org.apache.reef.wake.EventHandler;

import javax.inject.Inject;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.atomic.AtomicReference;
import java.util.logging.Level;
import java.util.logging.Logger;

/**
 * The task that loads a file given through {@link DriverMessage} and counts the number of records.
 * Task will finish after loading all files specified by clients.
 */
@TaskSide
@Unit
final class LineCountingTask implements Task, TaskMessageSource {
  private static final Logger LOG = Logger.getLogger(LineCountingTask.class.getName());

  private final AtomicReference<byte[]> msgToSend = new AtomicReference<>(null);

  private final CountDownLatch finishedLatch = new CountDownLatch(1);


  @Inject
  private LineCountingTask() {
  }

  @Override
  public byte[] call(final byte[] bytes) throws Exception {
    // wait until CloseEvent has been received. See {@link CloseEventHandler}.
    finishedLatch.await();
    return null;
  }

  // A message generated by {@link DriverMsgHandler}.
  @Override
  public Optional<TaskMessage> getMessage() {
    final byte[] msg = msgToSend.getAndSet(null);

    return msg == null ?
        Optional.empty() :
        Optional.of(TaskMessage.from(LineCountingTask.class.getName(), msg));
  }

  /**
   * A driver message handler that loads a file split given in the message.
   * It counts lines in the split and report it to driver through heartbeat.
   */
  final class DriverMsgHandler implements EventHandler<DriverMessage> {

    @Override
    public void onNext(final DriverMessage driverMessage) {
      final Optional<byte[]> bytes = driverMessage.get();

      final DataSet<LongWritable, Text> dataSet;
      try {
        dataSet = new RawDataSet<>(bytes.get());
      } catch (final IOException e) {
        throw new RuntimeException("Exception while instantiating a RawDataSet", e);
      }

      LOG.log(Level.FINER, "LineCounting task started");

      int count = 0;
      for (final Pair<LongWritable, Text> recordPair : dataSet) {
        LOG.log(Level.FINEST, "Read line: {0}", recordPair);
        count++;
      }

      LOG.log(Level.FINER, "LineCounting task finished: read {0} lines", count);
      msgToSend.set(Integer.toString(count).getBytes(StandardCharsets.UTF_8));
    }
  }

  final class CloseEventHandler implements EventHandler<CloseEvent> {
    @Override
    public void onNext(final CloseEvent closeEvent) {
      finishedLatch.countDown();
    }
  }
}
